## allow command substitutions
setopt PROMPT_SUBST

## enable color names
autoload -Uz colors && colors

## return the current git repo name and branch/tag (if inside a repo)
parse_git_info() {
  ## return early if not inside a git repo
  git rev-parse --is-inside-work-tree &>/dev/null || return
  ## local repo folder name (basename of toplevel path)
  local toplevel repo_local
  toplevel=$(git rev-parse --show-toplevel 2>/dev/null) || return
  repo_local=${toplevel:t}
  ## extract remote repo name (basename of remote.origin.url)
  local remote_url remote_name
  remote_url=$(git config --get remote.origin.url 2>/dev/null)
  if [[ -n $remote_url ]]; then
    remote_name=${remote_url:t} # take last path component
    remote_name=${remote_name%.git} # strip .git suffix
  fi
  ## normalize names for comparison: lowercase + remove underscores and dashes
  local repo_norm remote_norm
  repo_norm=${repo_local:l}
  repo_norm=${repo_norm//[_-]/}
  remote_norm=${remote_name:l}
  remote_norm=${remote_norm//[_-]/}
  ## decide display name:
  ## show alias form (local->remote) only if normalized names differ
  local repo_display=$repo_local
  if [[ -n $remote_name && $remote_norm != $repo_norm ]]; then
    repo_display="$repo_local->$remote_name"
  fi
  ## current branch or tag (fallback to 'detached' if neither)
  local branch
  branch=$(
    git symbolic-ref --quiet --short HEAD 2>/dev/null || \
    git describe --tags --exact-match 2>/dev/null || echo "detached"
  )
  ## final formatted output
  echo " ($repo_display | $branch)"
}

PROMPT=$'%F{cyan}%~%f'                         # line 1: full path
PROMPT+=$'\n[%*] %F{green}%n%f: %F{yellow}%1~%f' # line 2: timestamp + user info
PROMPT+=$'%F{red}$(parse_git_info)%f'            # line 2: git repo + branch
PROMPT+=$'\n-> '                                 # line 3: prompt symbol

## insert a blank line between the command and its output
preexec() { print -r -- ""; }
# unset -f preexec # uncomment to undo effect

## .