###############################################################################
## Git helpers (FF-first, merge-when-diverged) + probes (teaching-friendly)
##
## Runtime toggles (env-vars):
##   GIT_VERBOSE=1  # default  -> print decisions + the exact git commands
##   GIT_VERBOSE=0  #          -> quiet mode
##
##   GIT_DRYRUN=1   #          -> show commands, but DO NOT execute them
##   GIT_DRYRUN=0   # default  -> execute normally
##
##   GIT_ALLOW_DIRTY=1  #          -> allow g_sync_branch/merges with uncommitted changes
##   GIT_ALLOW_DIRTY=0  # default  -> require a clean worktree (safer)
##
## One-time global config (recommended):
##   g_set_global_config  # sets: pull.rebase=false, pull.ff=true, merge.ff=true, rerere.enabled=true
###############################################################################

##
## === LOGGING
##

## Defn:
##   _log <message...>
## Purpose:
##   Conditional stderr logger controlled by GIT_VERBOSE (default 1).
## Usage:
##   _log "decision: doing X"
_log() { [ "${GIT_VERBOSE:-1}" != "0" ] && printf '%s\n' "$*" >&2; }

## Defn:
##   _log_step <message...>
## Purpose:
##   Pedagogical breadcrumb: narrate each major step. Respects GIT_VERBOSE.
## Usage:
##   _log_step "determining upstream"
_log_step() { _log "STEP: $*"; }

## Defn:
##   _log_outcome <message...>
## Purpose:
##   Call out a chosen path / result clearly after a decision.
## Usage:
##   _log_outcome "using plain push (upstream exists)"
_log_outcome() { _log "OUTCOME: $*"; }

## Defn:
##   _bind_var <name> <value>
## Purpose:
##   Show “variable binding” so learners see state moving between steps.
## Usage:
##   _bind_var upstream_ref "$upstream_ref"
_bind_var() { _log "SET: $1 = ${2-}"; }

## Defn:
##   _die <message>
## Purpose:
##   Send an error message to stderr and return non-zero from the current function.
## Usage:
##   some_check || { _die "explanation"; return 1; }
_die() { printf 'error: %s\n' "$*" >&2; return 1; }

## Defn:
##   _run <cmd> [args...]
## Purpose:
##   Log and execute argv-style command; in dry-run, mark as skipped.
## Usage:
##   _run git fetch --prune origin
_run() {
  if [ "${GIT_DRYRUN:-0}" = "1" ]; then
    _log "+ (dryrun) skipped: $*"
    return 0
  fi
  _log "+ $*"
  command "$@"
}

## Defn:
##   _run_sh '<shell command>'
## Purpose:
##   Like _run, but for pipelines / && / || as a single unit. Uses eval.
## Usage:
##   _run_sh 'git remote -v | sort -u'
_run_sh() {
  local cmd="$*"
  if [ "${GIT_DRYRUN:-0}" = "1" ]; then
    _log "+ (dryrun) skipped: $cmd"
    return 0
  fi
  _log "+ $cmd"
  ( set -o pipefail; eval "$cmd" )
}

## Defn:
##   _run_and_capture <cmd> [args...]
## Purpose:
##   Run argv-style command, return stdout (for $(...)). Dry-run -> log + empty.
## Usage:
##   out="$(_run_and_capture git rev-parse --abbrev-ref HEAD)"
_run_and_capture() {
  if [ "${GIT_DRYRUN:-0}" = "1" ]; then
    _log "+ (dryrun) skipped: $*"
    return 0
  fi
  _log "+ $*"
  command "$@"
}

## Defn:
##   _probe <cmd> [args...]
## Purpose:
##   Log and execute argv-style read-only check (does NOT skip in dry-run).
## Usage:
##   _probe git rev-parse --is-inside-work-tree >/dev/null
_probe() {
  _log "? $*"
  command "$@"
}

## Defn:
##   _probe_sh '<shell command>'
## Purpose:
##   Shell-string probe variant (pipelines). Does not skip in dry-run.
## Usage:
##   _probe_sh 'git remote -v | wc -l'
_probe_sh() {
  local cmd="$*"
  _log "? $cmd"
  ( set -o pipefail; eval "$cmd" )
}

## Defn:
##   _probe_and_capture <cmd> [args...]
## Purpose:
##   Read-only argv-style query that returns stdout; runs even in dry-run.
## Usage:
##   out="$(_probe_and_capture git remote)"
_probe_and_capture() {
  _log "? $*"
  command "$@"
}

## Defn:
##   _probe_and_capture_sh '<shell command>'
## Purpose:
##   Shell-string read-only query returning stdout; runs even in dry-run.
## Usage:
##   out="$(_probe_and_capture_sh 'git symbolic-ref -q refs/remotes/origin/HEAD')"
_probe_and_capture_sh() {
  local cmd="$*"
  _log "? $cmd"
  ( set -o pipefail; eval "$cmd" )
}

##
## === GIT CONFIGURATION
##

## Purpose:
##   Configure global Git defaults for a fast-forward-first workflow and enable
##   rerere (reuse recorded conflict resolutions).
## Notes:
##   Writes to ~/.gitconfig (pull.rebase=false, pull.ff=true, merge.ff=true, rerere.enabled=true).
g_set_global_config() {
  _run git config --global pull.rebase false   || return $?
  _run git config --global pull.ff true        || return $?
  _run git config --global merge.ff true       || return $?
  _run git config --global rerere.enabled true || return $?
  printf "result: installed FF-first merge defaults globally in ~/.gitconfig"
}

## Purpose:
##   Display the current global Git settings that this helper module relies on.
## Notes:
##   Prints raw values and a short summary.
g_show_global_config() {
  printf "\nCurrent global Git configuration summary:\n"
  printf "\tpull.rebase    = %s\n" "$(git config --global --get pull.rebase || echo '(unset)')"
  printf "\tpull.ff        = %s\n"   "$(git config --global --get pull.ff || echo '(unset)')"
  printf "\tmerge.ff       = %s\n"   "$(git config --global --get merge.ff || echo '(unset)')"
  printf "\trerere.enabled = %s\n"   "$(git config --global --get rerere.enabled || echo '(unset)')"
  printf "Tip: edit directly via 'git config --global --edit' or run 'g_set_global_config'\n"
}

##
## === INTERNAL HELPERS
##

## Purpose:
##   Verify the current directory is inside a Git work tree.
## Usage:
##   _require_repo || return 1
_require_repo() {
  _probe git rev-parse --is-inside-work-tree >/dev/null 2>&1 || {
    _die "not inside a git repo"; return 1; }
}

## Purpose:
##   Ensure we are in a repo and that at least one remote is configured.
## Usage:
##   _require_remote || return 1
_require_remote() {
  _require_repo || return 1
  local remotes
  remotes="$(_probe_and_capture git remote)" || remotes=""
  if [ -z "$remotes" ] && [ "${GIT_DRYRUN:-0}" != "1" ]; then
    _die "no remotes configured (try: git remote add origin <url>)"
    return 1
  fi
}

## Purpose:
##   Pick the default remote name: prefer 'origin' if it exists, otherwise choose the first configured remote.
## Usage:
##   remote=$(_get_default_remote_name) || return 1
_get_default_remote_name() {
  _require_remote || return 1
  if _probe git remote get-url origin >/dev/null 2>&1; then
    _log_outcome "selecting 'origin' as default remote"
    printf %s "origin"; return 0
  fi
  local first_remote
  first_remote="$(_probe_and_capture_sh 'git remote | head -n1')"
  if [ -n "$first_remote" ]; then
    _log_outcome "selecting first configured remote: $first_remote"
    printf %s "$first_remote"; return 0
  fi
  _die "no remotes configured (try: git remote add origin <url>)"; return 1
}

## Purpose:
##   Strictly resolve the remote’s default branch via <remote>/HEAD; print nothing if undefined.
## Usage:
##   def=$(_get_default_branch_name)  # may be empty
_get_default_branch_name() {
  _require_remote || return 1
  local remote_name remote_head_ref default_branch_name
  remote_name=$(_get_default_remote_name) || return 0
  remote_head_ref="$(_probe_and_capture git symbolic-ref -q "refs/remotes/$remote_name/HEAD" 2>/dev/null)" || remote_head_ref=""
  [ -n "$remote_head_ref" ] || { _log_outcome "no remote default branch advertised"; printf ""; return 0; }
  default_branch_name=${remote_head_ref#refs/remotes/$remote_name/}
  _log_outcome "remote default branch is '$default_branch_name'"
  printf %s "$default_branch_name"
}

## Purpose:
##   Test whether the current branch has an upstream configured.
## Usage:
##   if _has_upstream; then ... fi
_has_upstream() {
  _require_repo || return 1
  _probe git rev-parse --abbrev-ref --symbolic-full-name '@{u}' >/dev/null 2>&1
}

## Purpose:
##   Print the current local branch name.
## Usage:
##   current_branch=$(_current_branch) || return 1
_current_branch() {
  _require_repo || return 1
  local name
  name="$(_probe_and_capture git rev-parse --abbrev-ref HEAD)"
  if [ "$name" = "HEAD" ]; then
    local sha; sha="$(_probe_and_capture git rev-parse --short HEAD)"
    _log_outcome "detached HEAD at $sha"
    printf 'DETACHED@%s' "$sha"
  else
    _log_outcome "on branch '$name'"
    printf %s "$name"
  fi
}

## Purpose:
##   Enforce a clean working tree unless GIT_ALLOW_DIRTY=1; abort if unstaged/uncommitted changes exist.
## Usage:
##   _ensure_clean_worktree || return 1
_ensure_clean_worktree() {
  _require_repo || return 1
  if [ "${GIT_ALLOW_DIRTY:-0}" = "1" ]; then
    _log_outcome "continuing despite dirty worktree (GIT_ALLOW_DIRTY=1)"
    return 0
  fi
  if ! _probe git diff --quiet || ! _probe git diff --cached --quiet; then
    _die "working tree not clean (stash/commit first). Try: git status --short"; return 1
  fi
  _log_outcome "worktree is clean"
}

##
## === PROBING HELPERS
##

## Purpose:
##   Check whether the current HEAD is detached (not on any branch).
## Returns:
##   0 if detached, 1 if attached to a branch, non-zero on error.
## Usage:
##   if g_is_detached; then echo "HEAD is detached"; fi
g_is_detached() {
  _require_repo || return 1

  _log_step "checking whether HEAD is attached to a branch"
  local ref
  ref="$(_probe_and_capture git symbolic-ref -q HEAD || true)"
  _bind_var ref "${ref:-<empty>}"

  if [ -z "$ref" ]; then
    _log_outcome "HEAD is detached (not on any branch)"
    return 0
  else
    _log_outcome "HEAD is attached to branch '${ref#refs/heads/}'"
    return 1
  fi
}

## Purpose:
##   Print the current branch, its upstream (if any), and the upstream’s latest commit.
## Usage:
##   g_show_upstream
g_show_upstream() {
  _require_repo || return 1
  _log_step "identifying current branch"
  local current_branch_name upstream_ref
  current_branch_name="$(_current_branch)" || { _die "not inside a git repo"; return 1; }
  printf 'local branch: %s\n' "$current_branch_name"
  _log_step "resolving upstream (if any)"
  upstream_ref=""
  if _has_upstream; then
    upstream_ref="$(_probe_and_capture git rev-parse --abbrev-ref --symbolic-full-name '@{u}')" || upstream_ref=""
  fi
  if [ -n "$upstream_ref" ]; then
    printf 'upstream:     %s\n' "$upstream_ref"
    _log_step "showing the latest commit on the upstream"
    _run git log --oneline --decorate -1 "$upstream_ref"
    _log_outcome "upstream detected: $upstream_ref"
  else
    _log_outcome "no upstream configured for current branch"
    echo "upstream:     (none)"
  fi
}

## Purpose:
##   Update remote-tracking refs (fetch --prune) and show local branches with upstream and ahead/behind info.
## Usage:
##   g_branches_status
g_branches_status() {
  _require_repo || return 1
  _log_step "refreshing remote-tracking information"
  _run git fetch --prune --quiet || return $?
  _log_step "showing local branches with upstream and ahead/behind"
  _run git branch -vv --no-abbrev
}

## Purpose:
##   Display ahead/behind counts versus upstream for the current branch.
## Usage:
##   g_ahead_behind
g_ahead_behind() {
  _require_repo || return 1
  local upstream_ref ahead behind counts
  _log_step "determining upstream for current branch"
  if _has_upstream; then
    upstream_ref="$(_probe_and_capture git rev-parse --abbrev-ref --symbolic-full-name '@{u}')" || {
      _die "failed to resolve upstream ref"; return 1; }
    _bind_var upstream_ref "$upstream_ref"
  else
    _die "no upstream set for $(_current_branch)"; return 1
  fi
  _log_step "fetching latest refs from remote"
  _run git fetch --quiet || return $?
  _log_step "computing ahead/behind vs upstream"
  counts="$(_run_and_capture git rev-list --left-right --count HEAD..."$upstream_ref")" || return $?
  if [ -z "$counts" ] && [ "${GIT_DRYRUN:-0}" = "1" ]; then return 0; fi
  read -r ahead behind <<< "$counts"
  _bind_var ahead  "$ahead"
  _bind_var behind "$behind"
  printf "ahead: %s  behind: %s\n" "$ahead" "$behind"
}

## Purpose:
##   List commits present on the upstream that are not yet in the local branch.
## Usage:
##   g_unpulled_commits
g_unpulled_commits() {
  _require_repo || return 1
  local upstream_ref
  _log_step "determining upstream"
  if _has_upstream; then
    upstream_ref="$(_probe_and_capture git rev-parse --abbrev-ref --symbolic-full-name '@{u}')" || {
      _die "failed to resolve upstream ref"; return 1; }
  else
    _die "no upstream set"; return 1
  fi
  _bind_var upstream_ref "$upstream_ref"
  _log_step "fetching latest from remote"
  _run git fetch --quiet || return $?
  _log_step "listing commits present upstream but missing locally"
  _run git log --oneline HEAD.."$upstream_ref"
}

## Purpose:
##   List configured remotes and their URLs (unique lines).
## Usage:
##   g_remotes
g_remotes() {
  _require_repo || return 1
  _run_sh 'git remote -v | sort -u'
}

## Defn:
##   g_recent_commits [max_entries]
## Purpose:
##   Show recent commits on the current branch (default 20).
## Usage:
##   g_recent_commits
##   g_recent_commits 50
g_recent_commits() {
  _require_repo || return 1
  local max_entries="${1:-20}"
  _bind_var max_entries "$max_entries"
  _log_step "showing recent commits on current branch"
  _run git log --oneline --decorate -n "$max_entries"
}

## Purpose:
##   Display submodule SHA/status if present; otherwise print a helpful message.
## Usage:
##   g_submodules_status
g_submodules_status() {
  _require_repo || return 1
  _run_sh 'git submodule status || echo "No submodules or not initialized."'
}

## Defn:
##   g_rename_last_commit <message...>
## Purpose:
##   Rename (amend) the message of the most recent commit.
## Usage:
##   g_rename_last_commit "New message"
## Notes:
##   - Only changes the *most recent* commit.
##   - Does not alter the commit content (just the message).
##   - Use with care if you’ve already pushed the commit.
g_rename_last_commit() {
  _require_repo || return 1
  [ -z "$1" ] && { _die "usage: g_rename_last_commit \"<new message>\""; return 1; }
  if ! _probe git rev-parse --verify HEAD >/dev/null 2>&1; then
    _die "no commits yet (nothing to amend)"; return 1
  fi
  local new_msg="$*"
  _bind_var new_msg "$new_msg"
  _log_step "renaming last commit"
  _log "note: this rewrites commit history; avoid if already pushed"
  _run git commit --amend -m "$new_msg"
  _log_outcome "amended last commit message"
}

## Defn:
##   g_delete_local_branch <branch>
## Purpose:
##   Delete a local branch safely (-d). Fails if unmerged or if it's the current branch.
## Usage:
##   g_delete_local_branch feature/foo
g_delete_local_branch() {
  _require_repo || return 1
  if g_is_detached; then
    _die "operation not valid in detached HEAD state"
    return 1
  fi
  [ -z "$1" ] && { _die "usage: g_delete_local_branch <branch>"; return 1; }
  local b="$1"
  _log_step "verifying not deleting the current branch"
  if [ "$(_current_branch)" = "$b" ]; then _die "cannot delete the current branch"; return 1; fi
  _log_step "deleting local branch (-d)"
  _run git branch -d -- "$b"
  _log_outcome "deleted local branch '$b'"
}

## Defn:
##   g_prune_gone_locals
## Purpose:
##   Delete local branches whose upstream is [gone] (deleted on remote).
## Usage:
##   g_prune_gone_locals
g_prune_gone_locals() {
  _require_repo || return 1
  if g_is_detached; then
    _die "operation not valid in detached HEAD state"
    return 1
  fi
  _log_step "refreshing remote-tracking refs (fetch --prune)"
  _run git fetch --prune --quiet || return $?
  _log_step "finding local branches with [gone] upstream"
  local gone
  gone="$(_probe_and_capture_sh "git for-each-ref --format='%(refname:short) %(upstream:track)' refs/heads | awk '/\\[gone\\]/{print \$1}'")"
  [ -z "$gone" ] && { _log_outcome "no [gone] local branches"; return 0; }
  _bind_var to_delete "$gone"
  _log_step "deleting [gone] local branches (-d)"
  printf '%s\n' "$gone" | while IFS= read -r b; do [ -n "$b" ] && _run git branch -d -- "$b"; done
  _log_outcome "deleted [gone] local branches"
}

## Defn:
##   g_prune_merged_locals [base_ref]
## Purpose:
##   Delete local branches fully merged into <base_ref>. Defaults to the remote’s default branch, else HEAD.
## Usage:
##   g_prune_merged_locals
##   g_prune_merged_locals origin/main
g_prune_merged_locals() {
  _require_repo || return 1
  if g_is_detached; then
    _die "operation not valid in detached HEAD state"
    return 1
  fi
  _log_step "resolving base reference for merge checks"
  local base="$1"
  if [ -z "$base" ]; then
    local r d
    r=$(_get_default_remote_name) || r=""
    d=$(_get_default_branch_name) || d=""
    if [ -n "$r" ] && [ -n "$d" ]; then
      base="$r/$d"
    else
      base="HEAD"
    fi
  fi
  _bind_var base "$base"
  _log_step "finding branches fully merged into $base"
  local protect_regex='^(main|master|trunk|develop|development|release|stable)$'
  local current_branch
  local merged
  current_branch="$(_current_branch)" || return 1
  merged="$(_probe_and_capture_sh "
    git branch --format='%(refname:short)' --merged \"$base\" \
    | sed 's/^\\* \\?//' \
    | grep -Ev \"$protect_regex\" \
    | grep -v \"^$current_branch$\"
  ")"
  [ -z "$merged" ] && { _log_outcome "no fully merged local branches to delete"; return 0; }
  _bind_var to_delete "$merged"
  _log_step "deleting fully merged local branches (-d)"
  printf '%s\n' "$merged" | while IFS= read -r b; do [ -n "$b" ] && _run git branch -d -- "$b"; done
  _log_outcome "deleted fully merged local branches into $base"
}

## Defn:
##   g_cleanup_local_branches [base_ref]
## Purpose:
##   End-to-end cleanup: fetch --prune, delete [gone] locals, then delete locals merged into base.
## Usage:
##   g_cleanup_local_branches
##   g_cleanup_local_branches origin/main
g_cleanup_local_branches() {
  _require_repo || return 1
  if g_is_detached; then
    _die "operation not valid in detached HEAD state"
    return 1
  fi
  _log_step "refreshing remote-tracking refs (fetch --prune)"
  _run git fetch --prune --quiet || return $?
  g_prune_gone_locals || return $?
  g_prune_merged_locals "$1" || return $?
  _log_outcome "completed local branch cleanup"
}

##
## === MAIN WORKFLOW
##

## Defn:
##    g_track_remote_branch <remote>/<branch> [local_branch]
## Purpose:
##    Create a local branch that tracks an existing remote branch.
## Usage:
##    g_track_remote_branch origin/feature-x
##    g_track_remote_branch upstream/release-1.4 rel-1.4
g_track_remote_branch() {
  _require_remote || return 1
  [ -z "$1" ] && { _die "usage: g_track_remote_branch <remote>/<branch> [local_branch]"; return 1; }
  case "$1" in */*) : ;; *) _die "argument must be remote-qualified, e.g. origin/feature-x"; return 1 ;; esac
  local remote_branch="$1"
  local local_branch="${2:-${remote_branch#*/}}"
  _log_step "fetching latest remote refs"; _bind_var remote_branch "$remote_branch"; _bind_var local_branch "$local_branch"
  _run git fetch --prune "${remote_branch%%/*}" || return $?
  _log_step "creating local branch and setting it to track the remote branch"
  _run git switch -c "$local_branch" --track "$remote_branch"
  _log_outcome "created '$local_branch' to track '$remote_branch'"
}

## Defn:
##   g_create_branch_from_default <new_branch>
## Purpose:
##   Create a new branch from the remote’s declared default branch and publish it with upstream set.
## Usage:
##   g_create_branch_from_default my-feature
## Notes:
##   Fails with guidance if the remote’s default branch is not set; suggests using g_create_branch_from_remote.
g_create_branch_from_default() {
  _require_remote || return 1
  [ -z "$1" ] && { _die "usage: g_create_branch_from_default <new_branch>"; return 1; }
  local new_branch="$1" remote_name base_branch
  _bind_var new_branch "$new_branch"
  _log_step "selecting default remote"
  remote_name=$(_get_default_remote_name) || { _die "not inside a git repo"; return 1; }
  _bind_var remote_name "$remote_name"
  _log_step "fetching remote refs"
  _run git fetch --prune "$remote_name" || return $?
  _log_step "discovering remote default branch (<remote>/HEAD)"
  base_branch=$(_get_default_branch_name)
  if [ -z "$base_branch" ]; then
    cat >&2 <<EOF
No remote default branch is set (refs/remotes/${remote_name}/HEAD unknown).
Be explicit:
  g_create_branch_from_remote $new_branch ${remote_name}/<base_branch>
Example:
  g_create_branch_from_remote $new_branch ${remote_name}/development
Inspect the remote:
  git remote show $remote_name
EOF
    return 1
  fi
  _bind_var base_branch "$base_branch"
  _log_step "creating local branch from remote default (no tracking)"
  _run git switch -c "$new_branch" --no-track "$remote_name/$base_branch" || { _die "failed to create branch"; return 1; }
  _log_step "publishing branch and setting upstream (-u)"
  _run git push -u "$remote_name" HEAD || { _log "note: local branch created; publish later via: git push -u $remote_name HEAD"; return 1; }
  _log_outcome "created '$new_branch' from '$remote_name/$base_branch' and set upstream to '$remote_name/$new_branch'"
}

## Defn:
##   g_create_branch_from_remote <new_branch> <remote>/<base_branch>
## Purpose:
##   Create a new local branch from an explicit remote start point and publish with upstream.
## Usage:
##   g_create_branch_from_remote hotfix-1 origin/release-1.4
g_create_branch_from_remote() {
  _require_remote || return 1
  [ -z "$1" ] || [ -z "$2" ] && { _die "usage: g_create_branch_from_remote <new_branch> <remote>/<base_branch>"; return 1; }
  local new_branch="$1" start_ref="$2" remote_name
  case "$start_ref" in */*) : ;; *) _die "startpoint must be remote-qualified, e.g. origin/development"; return 1 ;; esac
  _bind_var new_branch "$new_branch"; _bind_var start_ref "$start_ref"
  _log_step "selecting default remote"
  remote_name=$(_get_default_remote_name) || { _die "not inside a git repo"; return 1; }
  _bind_var remote_name "$remote_name"
  _log_step "fetching remote refs"
  _run git fetch --prune "$remote_name" || return $?
  _log_step "creating local branch from explicit start point (no tracking)"
  _run git switch -c "$new_branch" --no-track "$start_ref" || { _die "failed to create branch"; return 1; }
  _log_step "publishing branch and setting upstream (-u)"
  _run git push -u "$remote_name" HEAD || { _log "note: local branch created; publish later via: git push -u $remote_name HEAD"; return 1; }
  _log_outcome "created '$new_branch' from '$start_ref' and set upstream to '$remote_name/$new_branch'"
}

## Defn:
##   g_push [extra git push args...]
## Purpose:
##   Push the current branch; if no upstream exists, creates it as <remote>/<same-name> with -u.
## Usage:
##   g_push
##   g_push --tags
g_push() {
  _require_remote || return 1
  if g_is_detached; then
    _die "operation not valid in detached HEAD state"
    return 1
  fi
  _log_step "publishing current branch"
  local remote_name; remote_name=$(_get_default_remote_name) || { _die "not inside a git repo"; return $?; }
  _bind_var remote_name "$remote_name"
  _log_step "detecting whether upstream is already set"
  if _has_upstream; then
    _log_outcome "using plain push (upstream already set)"
    _run git push "$@"
  else
    _log_outcome "creating upstream and pushing with -u to ${remote_name}/<same-name>"
    _run git push -u "$remote_name" HEAD "$@"
  fi
}

## Defn:
##   g_sync_branch [<remote>/<base_branch>]
## Purpose:
##   FF-first sync of the current branch: pull --ff if upstream exists; else optionally merge an explicit base.
## Usage:
##   g_sync_branch
##   g_sync_branch origin/development
## Notes:
##   Requires a clean worktree unless GIT_ALLOW_DIRTY=1.
g_sync_branch() {
  _require_remote || return 1
  if g_is_detached; then
    _die "operation not valid in detached HEAD state"
    return 1
  fi
  local remote_name base_ref
  _log_step "identifying default remote"
  remote_name=$(_get_default_remote_name) || { _die "not inside a git repo"; return $?; }
  _bind_var remote_name "$remote_name"
  _log_step "verifying clean worktree (unless GIT_ALLOW_DIRTY=1)"
  _ensure_clean_worktree || return $?
  _log_step "fetching from remote"
  _run git fetch --prune "$remote_name" || return $?
  _log_step "deciding on the sync method"
  if _has_upstream; then
    _log_step "pulling with --ff"
    _run git pull --ff
    _log_outcome "synced via 'git pull --ff' (fast-forward if possible; merge if diverged by Git)"
  else
    if [ -n "$1" ]; then
      base_ref="$1"
      case "$base_ref" in */*) : ;; *) _die "base must be remote-qualified, e.g. origin/development"; return 1 ;; esac
      _bind_var base_ref "$base_ref"
      _log_step "merging explicit base into current branch with --ff"
      _run git merge --ff "$base_ref"
      _log_outcome "synced by merging '$base_ref' into current branch (fast-forward if possible)"
    else
      _die "no upstream set; publish (g_push) or provide a base: g_sync_branch <remote>/<base_branch>"
      return 1
    fi
  fi
}

## .
